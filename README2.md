## Реализовать механизмы, увеличивающие отказоустойчивость системы:

* На Gateway Service для _всех операций_ чтения реализовать паттерн Circuit Breaker. Накапливать статистику в памяти, и
  если система не ответила N раз, то в N+1 раз вместо запроса сразу отдавать fallback. Через небольшой timeout выполнить
  запрос к реальной системе, чтобы проверить ее состояние.
* В случае недоступности данных из некритичного источника (не основного), возвращается fallback-ответ. В зависимости от
  ситуации, это может быть:
    * пустой объект или массив;
    * объект, с заполненным полем (`uid` или подобным), по которому идет связь с другой системой;
    * default строка (если при этом не меняется тип переменной).
* В задании описаны две операции, изменяющие состояния нескольких систем. В случае недоступности одной из систем,
  участвующих в этой операции, выполнить:
    * откат всей операции;
    * возвращать пользователю ответ об успешном завершении операции, а на Gateway Service поставить этот запрос в
      очередь для повторного выполнения.

1. Для реализации очереди можно использовать language native реализацию (например, BlockingQueue для Java), либо
   какую-то готовую реализацию типа RabbitMQ, Redis, ZeroMQ и т.п. Крайне нежелательно использовать реляционную базу
   данных как средство эмуляции очереди.
1. Выключается сервис loyalty и проверяется корректность работы остальных. Для
   этого используется Heroku API, сервис переводится в Maintenance Mode. 
   Для этого в [classroom.yml](.github/workflows/classroom.yml) раскомментировать блок `Run API Tests 2`
   Там прописано:
   ```
   envVar: '[{ "key": "serviceName", "value": "loyalty-service-lab2" }, { "key": "herokuApiToken", "value": "${{secrets.HEROKU_API_KEY}}" }]'
   ```
1. Чтобы `HEROKU_API_KEY` не зашивать в коде, его нужно прописать в `Settings` -> `Secrets`.
   (1d2d9518-5fe3-4db2-a191-88313365f768)

Если метод требует получения данных из нескольких источников, то в случае недоступности одного _не критичного_
источника, недостающие данные возвращаются как некоторый fallback ответ, а остальные данные подставляются из
успешного запроса.

Например, метод `GET /api/v1/loyalty` в случае недоступности Loyalty Service должен вернуть 500 ошибку, т.к. данные,
получаемые из этого сервиса критичные.

Аналогично для метода `GET /api/v1/me`, в случае недоступности Loyalty Service, пользователю
возвращается fallback ответ.

##### Бронирование отеля

1. Запрос к Reservation Service для проверки, что такой отель существует. 
1. Выполняется запрос к Payment Service для создания оплате. 
1. Выполняется запрос к Loyalty Service для увеличения счетчика бронирований и, возможно, как следствие этого, изменения
   статуса клента.
1. Если запрос к Loyalty Service завершился неудачей (500 ошибка или сервис недоступен), то выполняется откат операции
   оплаты в Ticket Service.

##### Отмена бронирования

1. Выполняется запрос к Payment Service для отмены оплаты (устанавливается статус `CANCELED`). 
1. После этого выполняется запрос к Loyalty Service для уменьшения счетчика бронирований и, возможно, если счетчик стал
   ниже уровня, понижения статуса пользователя. Если этот сервис недоступен, то пользователю все равно отдается
   информация что операция завершилась успешно, а на Gateway Service запрос ставится в очередь и повторяется пока не
   завершится успехом (timeout 10 секунд).